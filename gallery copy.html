<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <title>Tilt Gallery — Independent Cards Toward Mouse</title>

    <!-- Bootstrap CSS -->
    <link
      href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/css/bootstrap.min.css"
      rel="stylesheet"
    />

    <style>
      body {
        background: #f4f6f8;
      }

      .tilt-wrapper {
        perspective: 1200px;
        border-radius: 14px;
        overflow: hidden;
        will-change: transform;
        transition: box-shadow 200ms ease;
        cursor: pointer;
        height: 220px;
        display: flex;
        align-items: stretch;
      }

      .tilt-wrapper .img-inner {
        width: 100%;
        height: 100%;
        display: block;
        object-fit: cover;
      }

      .tilt-wrapper:hover {
        box-shadow: 0 18px 40px rgba(16, 24, 40, 0.18);
      }

      /* Modal style */
      .modal-content {
        background: transparent;
        border: none;
      }
      .modal-navigation {
        position: absolute;
        top: 50%;
        width: 100%;
        display: flex;
        justify-content: space-between;
        transform: translateY(-50%);
        pointer-events: none; /* enable only the buttons */
      }
      .modal-navigation button {
        pointer-events: auto;
        background: rgba(0, 0, 0, 0.45);
        border: none;
        color: white;
        font-size: 1.6rem;
        border-radius: 50%;
        width: 52px;
        height: 52px;
        display: flex;
        align-items: center;
        justify-content: center;
      }
      .modal-navigation button:hover {
        background: rgba(0, 0, 0, 0.65);
      }
      #lightboxImage {
        max-height: 80vh;
      }
    </style>
  </head>
  <body>
    <div class="container py-5">
      <div class="row g-4" id="gallery">
        <!-- example images -->
        <div class="col-12 col-sm-6 col-md-4">
          <div class="tilt-wrapper">
            <img
              class="img-inner"
              src="https://picsum.photos/id/1011/900/600"
              alt=""
            />
          </div>
        </div>
        <div class="col-12 col-sm-6 col-md-4">
          <div class="tilt-wrapper">
            <img
              class="img-inner"
              src="https://picsum.photos/id/1015/900/600"
              alt=""
            />
          </div>
        </div>
        <div class="col-12 col-sm-6 col-md-4">
          <div class="tilt-wrapper">
            <img
              class="img-inner"
              src="https://picsum.photos/id/1020/900/600"
              alt=""
            />
          </div>
        </div>
        <div class="col-12 col-sm-6 col-md-4">
          <div class="tilt-wrapper">
            <img
              class="img-inner"
              src="https://picsum.photos/id/1024/900/600"
              alt=""
            />
          </div>
        </div>
        <div class="col-12 col-sm-6 col-md-4">
          <div class="tilt-wrapper">
            <img
              class="img-inner"
              src="https://picsum.photos/id/1025/900/600"
              alt=""
            />
          </div>
        </div>
        <div class="col-12 col-sm-6 col-md-4">
          <div class="tilt-wrapper">
            <img
              class="img-inner"
              src="https://picsum.photos/id/1031/900/600"
              alt=""
            />
          </div>
        </div>
      </div>
    </div>

    <!-- Lightbox Modal -->
    <div class="modal fade" id="lightboxModal" tabindex="-1" aria-hidden="true">
      <div
        class="modal-dialog modal-dialog-centered modal-xl position-relative"
      >
        <div class="modal-content text-center">
          <button
            type="button"
            class="btn-close btn-close-white position-absolute top-0 end-0 m-3"
            data-bs-dismiss="modal"
            aria-label="Close"
          ></button>
          <img
            id="lightboxImage"
            src=""
            alt=""
            class="img-fluid rounded shadow"
          />
          <div class="modal-navigation">
            <button id="prevBtn" aria-label="Previous">‹</button>
            <button id="nextBtn" aria-label="Next">›</button>
          </div>
        </div>
      </div>
    </div>

    <!-- Bootstrap JS bundle -->
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/js/bootstrap.bundle.min.js"></script>

    <script>
      /* -------- Configuration -------- */
      const maxTilt = 15; // degrees, change to 30+ for more dramatic tilt
      const scaleOnHover = 1.06; // scale for hovered/active look
      const lerpFactor = 0.12; // animation smoothness (0-1), higher = snappier
      const disableOnTouch = true; // disable tilt on touch devices by default

      /* -------- Helpers -------- */
      const clamp = (v, a, b) => Math.max(a, Math.min(b, v));
      const lerp = (a, b, t) => a + (b - a) * t;
      const isTouchDevice = () =>
        "ontouchstart" in window || navigator.maxTouchPoints > 0;

      /* -------- Setup elements & state -------- */
      const wrappers = Array.from(document.querySelectorAll(".tilt-wrapper"));
      const images = wrappers.map((w) => w.querySelector(".img-inner"));
      const gallery = document.getElementById("gallery");
      const modalEl = document.getElementById("lightboxModal");
      const bootstrapModal = new bootstrap.Modal(modalEl);
      const modalImg = document.getElementById("lightboxImage");

      let centers = []; // cached centers for each wrapper {cx, cy, w, h}
      let animating = false;
      let mouse = {
        x: window.innerWidth / 2,
        y: window.innerHeight / 2,
        inside: false,
      };
      let isTouch = isTouchDevice() && disableOnTouch;
      let rAFId = null;
      let modalOpen = false;
      let currentIndex = 0;

      /* init per-wrapper state */
      wrappers.forEach((w) => {
        w._current = { rx: 0, ry: 0, s: 1 };
        w._target = { rx: 0, ry: 0, s: 1 };
        w.style.transformStyle = "preserve-3d";
      });

      /* compute centers (call on load, resize, scroll) */
      function updateCenters() {
        centers = wrappers.map((w) => {
          const rect = w.getBoundingClientRect();
          return {
            cx: rect.left + rect.width / 2,
            cy: rect.top + rect.height / 2,
            w: rect.width,
            h: rect.height,
          };
        });
      }
      updateCenters();

      /* debounced resize/scroll updating */
      let resizeTimer = null;
      window.addEventListener("resize", () => {
        clearTimeout(resizeTimer);
        resizeTimer = setTimeout(() => {
          updateCenters();
        }, 120);
      });
      window.addEventListener("scroll", () => {
        clearTimeout(resizeTimer);
        resizeTimer = setTimeout(() => {
          updateCenters();
        }, 120);
      });

      /* pointer handling (use pointer events when available) */
      const MOVEEVENT = window.PointerEvent ? "pointermove" : "mousemove";
      const ENTER = window.PointerEvent ? "pointerenter" : "mouseenter";
      const LEAVE = window.PointerEvent ? "pointerleave" : "mouseleave";

      function onPointerMove(e) {
        if (isTouch || modalOpen) return;
        mouse.x = e.clientX;
        mouse.y = e.clientY;
        mouse.inside = true;
        // update targets for each wrapper
        wrappers.forEach((w, i) => {
          const c = centers[i];
          if (!c) return;
          // vector from wrapper center to mouse
          const dx = mouse.x - c.cx;
          const dy = mouse.y - c.cy;

          // normalize relative to viewport (so effect is consistent across screen)
          const nx = dx / (window.innerWidth / 2);
          const ny = dy / (window.innerHeight / 2);

          // target rotations — clamp to [-maxTilt, maxTilt]
          const targetRY = clamp(nx * maxTilt, -maxTilt, maxTilt); // rotateY (left<->right)
          const targetRX = clamp(-ny * maxTilt, -maxTilt, maxTilt); // rotateX (top<->bottom)

          w._target.rx = targetRX;
          w._target.ry = targetRY;
          w._target.s = scaleOnHover;
        });

        // ensure animation loop running
        if (!animating) {
          animating = true;
          rAFId = requestAnimationFrame(animate);
        }
      }

      function onPointerLeave(e) {
        // when pointer leaves viewport or gallery, ease back to zero
        mouse.inside = false;
        wrappers.forEach((w) => {
          w._target.rx = 0;
          w._target.ry = 0;
          w._target.s = 1;
        });
        if (!animating) {
          animating = true;
          rAFId = requestAnimationFrame(animate);
        }
      }

      /* animation loop: lerp current towards target and apply transform */
      function animate() {
        let needsFrame = false;
        wrappers.forEach((w) => {
          const cur = w._current;
          const tgt = w._target;

          // lerp each property
          cur.rx = lerp(cur.rx || 0, tgt.rx, lerpFactor);
          cur.ry = lerp(cur.ry || 0, tgt.ry, lerpFactor);
          cur.s = lerp(cur.s || 1, tgt.s, lerpFactor);

          // apply transform
          const transform = `perspective(1200px) rotateX(${cur.rx.toFixed(
            3
          )}deg) rotateY(${cur.ry.toFixed(3)}deg) scale(${cur.s.toFixed(4)})`;
          w.style.transform = transform;

          // detect if still animating (close enough)
          if (
            Math.abs(cur.rx - tgt.rx) > 0.01 ||
            Math.abs(cur.ry - tgt.ry) > 0.01 ||
            Math.abs(cur.s - tgt.s) > 0.001
          ) {
            needsFrame = true;
          }
        });

        if (needsFrame) {
          rAFId = requestAnimationFrame(animate);
        } else {
          animating = false;
          cancelAnimationFrame(rAFId);
        }
      }

      /* disable tilt on touch devices to prevent interference with scroll */
      if (!isTouch) {
        window.addEventListener(MOVEEVENT, onPointerMove, { passive: true });
        window.addEventListener("mouseout", (e) => {
          // when cursor leaves window (relatedTarget == null) reset
          if (!e.relatedTarget) onPointerLeave();
        });
        // reset on window blur
        window.addEventListener("blur", onPointerLeave);
      } else {
        // optional: you can enable a gentle follow on touchmove if you want
        // document.addEventListener('touchmove', ... );
      }

      /* -------- Modal / Lightbox logic (prev/next/keyboard) -------- */
      const allImages = Array.from(
        document.querySelectorAll(".tilt-wrapper .img-inner")
      );

      allImages.forEach((img, idx) => {
        img.dataset.index = idx;
        img.addEventListener("click", () => {
          currentIndex = idx;
          openModal(idx);
        });
      });

      function openModal(idx) {
        modalImg.src = allImages[idx].src;
        bootstrapModal.show();
        modalOpen = true;
      }

      function closeModal() {
        bootstrapModal.hide();
        modalOpen = false;
      }

      document.getElementById("prevBtn").addEventListener("click", () => {
        currentIndex = (currentIndex - 1 + allImages.length) % allImages.length;
        modalImg.src = allImages[currentIndex].src;
      });
      document.getElementById("nextBtn").addEventListener("click", () => {
        currentIndex = (currentIndex + 1) % allImages.length;
        modalImg.src = allImages[currentIndex].src;
      });

      /* pause tilt while modal is open */
      modalEl.addEventListener("shown.bs.modal", () => {
        modalOpen = true;
      });
      modalEl.addEventListener("hidden.bs.modal", () => {
        modalOpen = false;
        // gently reset tilt when modal closed
        onPointerLeave();
      });

      /* keyboard navigation (only when modal is shown) */
      document.addEventListener("keydown", (e) => {
        if (!modalOpen) return;
        if (e.key === "ArrowLeft") document.getElementById("prevBtn").click();
        if (e.key === "ArrowRight") document.getElementById("nextBtn").click();
        if (e.key === "Escape") bootstrapModal.hide();
      });
    </script>
  </body>
</html>
